---
layout: post
title: 为什么Linux内核不允许在中断中休眠？
date: 2012-06-01 12:31:45.000000000 -07:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Linux Kernel
tags: []
meta:
  _publicize_pending: '1'
  original_post_id: '2005'
  _wp_old_slug: '2005'
author:
  login: wangcong2015
  email: wangcong@rocketmail.com
  display_name: wangcong2015
  first_name: ''
  last_name: ''
permalink: "/2012/06/01/%e4%b8%ba%e4%bb%80%e4%b9%88linux%e5%86%85%e6%a0%b8%e4%b8%8d%e5%85%81%e8%ae%b8%e5%9c%a8%e4%b8%ad%e6%96%ad%e4%b8%ad%e4%bc%91%e7%9c%a0%ef%bc%9f/"
---
<p><!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"><br />
<html><body>
<p>我以前一直以为 Linux 内核之所以不允许在中断中休眠是因为中断上下文中无法获取 thread_info，task_struct 等进程相关的结构体，从而无法调度。</p>
<p>今天又重新看了一下相关的代码，发现实际上不是。在最新的代码中，x86 32 使用的 irq stack 中也保存了thread_info，我们可以看 execute_on_irq_stack() 的定义：</p>
<p>[c]<br />
union irq_ctx {<br />
        struct thread_info      tinfo;<br />
        u32                     stack[THREAD_SIZE/sizeof(u32)];<br />
} __attribute__((aligned(THREAD_SIZE)));</p>
<p>static inline int<br />
execute_on_irq_stack(int overflow, struct irq_desc *desc, int irq)<br />
{<br />
        union irq_ctx *curctx, *irqctx;<br />
        u32 *isp, arg1, arg2;</p>
<p>        curctx = (union irq_ctx *) current_thread_info();<br />
        irqctx = __this_cpu_read(hardirq_ctx);</p>
<p>        /*<br />
         * this is where we switch to the IRQ stack. However, if we are<br />
         * already using the IRQ stack (because we interrupted a hardirq<br />
         * handler) we can't do that and just have to keep using the<br />
         * current stack (which is the irq stack already after all)<br />
         */<br />
        if (unlikely(curctx == irqctx))<br />
                return 0;</p>
<p>        /* build the stack frame on the IRQ stack */<br />
        isp = (u32 *) ((char *)irqctx + sizeof(*irqctx));<br />
        irqctx-&gt;tinfo.task = curctx-&gt;tinfo.task;<br />
        irqctx-&gt;tinfo.previous_esp = current_stack_pointer;</p>
<p>        /* Copy the preempt_count so that the [soft]irq checks work. */<br />
        irqctx-&gt;tinfo.preempt_count = curctx-&gt;tinfo.preempt_count;</p>
<p>        if (unlikely(overflow))<br />
                call_on_stack(print_stack_overflow, isp);</p>
<p>        asm volatile("xchgl     %%ebx,%%esp     n"<br />
                     "call      *%%edi          n"<br />
                     "movl      %%ebx,%%esp     n"<br />
                     : "=a" (arg1), "=d" (arg2), "=b" (isp)<br />
                     :  "0" (irq),   "1" (desc),  "2" (isp),<br />
                        "D" (desc-&gt;handle_irq)<br />
                     : "memory", "cc", "ecx");<br />
        return 1;<br />
}<br />
[/c]</p>
<p>（注：x86 都已经使用 irq stack 了，和进程的内核栈独立开了，这样即使 irq 处理函数中占用了很多栈也不会影响外面的了。）</p>
<p>所以这不是问题。也就是说，技术上我们完全可以做到在中断中休眠。Linux 内核之所以没有这么做是出于设计上的原因。</p>
<p>如果这还不足以说明问题的话，还有个例子：do_page_fault() 也是在中断上下文中调用的（注：此处更严格的讲是 trap，而非 interrupt，但无论哪个都肯定不是普通的进程上下文，相对而言还算是中断上下文），但是它是可能休眠的，至少它明显调用了可能休眠的函数 down_read() 。</p>
<p>为什么要这么设计呢？因为在 Linux 内核中能让 do_page_fault() 休眠的地方基本上只有copy_from_user()，copy_to_user()（其它地方触发 page fault 会导致 oops），它们在使用用户空间的页面时可能会因为对应的页面不在物理内存中而触发 swap 等，即 handle_mm_fault() 所做的。这种情况下休眠是合理的，因为调用 copy_from_user() 的进程本身就是需要等待这个资源。休眠不就是为了等待资源吗？</p>
<p>为什么其它中断（注：此处是指 IRQ，或者严格意义上的 interrupt，非 trap）不能休眠？假设 CPU 上正在执行的是某个高优先级的进程 A，它本身没有使用任何网络通信，突然网卡中断来了，它被中断而且被休眠了，那么，这看起来就像是进程 A 本身在等待某网络资源，而实际上根本不是。</p>
<p>换句话说，如果在 IRQ 中休眠，被打断的当前进程很可能不是需要等待的进程，更进一步讲，在中断中我们根本无法知道到底是哪个进程需要休眠。更何况，这里还没有考虑到在某个中断中休眠会不会影响下一个中断之类的更复杂的问题。由此可见，如果真允许在中断中休眠的话，那么设计将会是很复杂的。</p>
<p>因此，这完全是一个设计的问题。中断中休眠技术上可实现，但设计上不好。</p>
<p>另外，Linux 内核中很多会休眠的函数会调用 might_sleep()，它是用来检测是否在中断上下文中，如果是就是触发一个警告 “BUG: sleeping function called from invalid context”。可是为什么 do_page_fault() 中的函数没有呢？这是因为普通的 IRQ 在进入处理函数之前都会调用 irq_enter()，它里面改变了进程的 preempt 的值：</p>
<p>[c]<br />
#define __irq_enter()<br />
        do {<br />
                account_system_vtime(current);<br />
                add_preempt_count(HARDIRQ_OFFSET);<br />
                trace_hardirq_enter();<br />
        } while (0)</p>
<p>void irq_enter(void)<br />
{<br />
        int cpu = smp_processor_id();</p>
<p>        rcu_irq_enter();<br />
        if (is_idle_task(current) &amp;&amp; !in_interrupt()) {<br />
                /*<br />
                 * Prevent raise_softirq from needlessly waking up ksoftirqd<br />
                 * here, as softirq will be serviced on return from interrupt.<br />
                 */<br />
                local_bh_disable();<br />
                tick_check_idle(cpu);<br />
                _local_bh_enable();<br />
        }</p>
<p>        __irq_enter();<br />
}<br />
[/c]</p>
<p>而 page fault 的话不会经过这个流程。这也从另一面证明了这是个设计的问题。</p>
<p>顺便说一句，比较新的 Linux 内核中已经支持中断线程化了：</p>
<p>[c]<br />
int request_threaded_irq(unsigned int irq, irq_handler_t handler,<br />
                         irq_handler_t thread_fn, unsigned long irqflags,<br />
                         const char *devname, void *dev_id)<br />
[/c]</p>
<p>所以一部分中断处理可以在进程上下文中完成了。</p>
<p></body></html></p>
