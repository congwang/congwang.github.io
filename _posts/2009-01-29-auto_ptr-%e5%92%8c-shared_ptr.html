---
layout: post
title: auto_ptr 和 shared_ptr
date: 2009-01-29 20:19:10.000000000 -08:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Programming
tags: []
meta:
  _publicize_pending: '1'
  original_post_id: '527'
  _wp_old_slug: '527'
author:
  login: wangcong2015
  email: wangcong@rocketmail.com
  display_name: wangcong2015
  first_name: ''
  last_name: ''
permalink: "/2009/01/29/auto_ptr-%e5%92%8c-shared_ptr/"
---
<p><!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"><br />
<html><body>
<p>偶然的机会看到boost里还有一个shared_ptr型智能指针，费解，C++标准库里不是有auto_ptr了已经？我们先翻出源代码来看看。</p>
<p>先看auto_ptr，因为它比较简单。既然它在标准库里，那么我们就在gcc的代码中找，恩，最后确定在libstdc++-v3/include/backward/auto_ptr.h里面。说实话，auto_ptr真是太简单了，里面的私有变量就一个：</p>
<p>private:<br />
  _Tp* _M_ptr;</p>
<p>其它操作皆是围绕这个进行的，你自己猜都能猜到，看看吧，构造函数中的一个：<br />
[cpp]<br />
explicit<br />
  auto_ptr(element_type* __p = 0) throw() : _M_ptr(__p) { }<br />
[/cpp]<br />
析构函数：<br />
[cpp]<br />
~auto_ptr() { delete _M_ptr; }<br />
[/cpp]<br />
重载的赋值运算符：<br />
[cpp]<br />
      template<br />
        auto_ptr&amp;<br />
        operator=(auto_ptr&amp; __a) throw()<br />
        {<br />
          reset(__a.release());<br />
          return *this;<br />
        }<br />
[/cpp]<br />
调用了自己的reset和release方法，按住不表，下面会介绍。重载的提领运算符：<br />
[cpp]<br />
      element_type&amp;<br />
      operator*() const throw()<br />
      {<br />
        _GLIBCXX_DEBUG_ASSERT(_M_ptr != 0);<br />
        return *_M_ptr;<br />
      }<br />
[/cpp]</p>
<p>成员运算符：<br />
[cpp]<br />
      element_type*<br />
      operator-&gt;() const throw()<br />
      {<br />
        _GLIBCXX_DEBUG_ASSERT(_M_ptr != 0);<br />
        return _M_ptr;<br />
      }<br />
[/cpp]</p>
<p>get()方法：</p>
<p>[cpp]<br />
      element_type*<br />
      get() const throw() { return _M_ptr; }<br />
[/cpp]</p>
<p>release()方法：<br />
[cpp]<br />
      element_type*<br />
      release() throw()<br />
      {<br />
        element_type* __tmp = _M_ptr;<br />
        _M_ptr = 0;<br />
        return __tmp;<br />
      }<br />
[/cpp]</p>
<p>reset()方法：<br />
[cpp]<br />
      void<br />
      reset(element_type* __p = 0) throw()<br />
      {<br />
        if (__p != _M_ptr)<br />
          {<br />
            delete _M_ptr;<br />
            _M_ptr = __p;<br />
          }<br />
      }<br />
[/cpp]</p>
<p>这些应该没什么难理解的，可能除了那个成员运算符，只说一句：C++会把foo-&gt;bar()翻译成：(foo.operator-&gt;())-&gt;bar()。</p>
<p>从上面我们可以看出，auto_ptr明显没有计数引用，而shared_ptr和它的最大区别就是它有计数。shared_ptr的源代码在boost/shared_ptr.hpp里。先看它的私有变量：</p>
<p>  T * px;                     // contained pointer<br />
  boost::detail::shared_count pn;    // reference counter</p>
<p>多了一个引用计数器，是一个boost::detail::shared_count类型，再翻源代码boost/detail/shared_count.hpp，只看用到的三个方法：<br />
[cpp]<br />
    bool unique() const // nothrow<br />
    {<br />
        return use_count() == 1;<br />
    }</p>
<p>    void swap(shared_count &amp; r) // nothrow<br />
    {<br />
        sp_counted_base * tmp = r.pi_;<br />
        r.pi_ = pi_;<br />
        pi_ = tmp;<br />
    }</p>
<p>    long use_count() const // nothrow<br />
    {<br />
        return pi_ != 0? pi_-&gt;use_count(): 0;<br />
    }</p>
<p>[/cpp]<br />
呃，还有一个不能漏了，赋值运算符：<br />
[cpp]<br />
    shared_count &amp; operator= (shared_count const &amp; r) // nothrow<br />
    {<br />
        sp_counted_base * tmp = r.pi_;</p>
<p>        if( tmp != pi_ )<br />
        {<br />
            if( tmp != 0 ) tmp-&gt;add_ref_copy();<br />
            if( pi_ != 0 ) pi_-&gt;release();<br />
            pi_ = tmp;<br />
        }</p>
<p>        return *this;<br />
    }<br />
[/cpp]<br />
再回过头去看shared_ptr的源代码：<br />
[cpp]<br />
    reference operator* () const // never throws<br />
    {<br />
        BOOST_ASSERT(px != 0);<br />
        return *px;<br />
    }</p>
<p>    T * operator-&gt; () const // never throws<br />
    {<br />
        BOOST_ASSERT(px != 0);<br />
        return px;<br />
    }</p>
<p>    T * get() const // never throws<br />
    {<br />
        return px;<br />
    }</p>
<p>    bool operator! () const // never throws<br />
    {<br />
        return px == 0;<br />
    }</p>
<p>    bool unique() const // never throws<br />
    {<br />
        return pn.unique();<br />
    }</p>
<p>    long use_count() const // never throws<br />
    {<br />
        return pn.use_count();<br />
    }</p>
<p>    void swap(shared_ptr &amp; other) // never throws<br />
    {<br />
        std::swap(px, other.px);<br />
        pn.swap(other.pn);<br />
    }</p>
<p>    shared_ptr &amp; operator=( shared_ptr &amp;&amp; r ) // never throws<br />
    {<br />
        this_type( static_cast( r ) ).swap( *this );<br />
        return *this;<br />
    }<br />
[/cpp]</p>
<p>这样一切都明了了。所以，auto_ptr和shared_ptr在使用上的区别也好理解了，下面的小程序可以展示：</p>
<p>[cpp]<br />
#include<br />
#include<br />
#include </p>
<p>using namespace boost;<br />
using std::cout;<br />
using std::endl;<br />
using std::auto_ptr;</p>
<p>class A<br />
{<br />
	public:<br />
	void print()<br />
	{<br />
		cout&lt;&lt;"hello"&lt;&lt;endl;<br />
	}<br />
};</p>
<p>int main()<br />
{<br />
	auto_ptr<a> aptr1(new A);<br />
	auto_ptr</a><a> aptr2;</p>
<p>	aptr2 = aptr1;<br />
	aptr2-&gt;print(); //Ok<br />
	cout&lt;&lt;"pointer in aptr1 is: "&lt;&lt;aptr1.get()&lt;print(); //Wrong!</p>
<p>	A * a = new A;<br />
	shared_ptr</a><a> sptr1(a);<br />
	shared_ptr</a><a> sptr2(sptr1); //alright<br />
	sptr2 = sptr1;<br />
	sptr2-&gt;print(); //ok<br />
	sptr1-&gt;print(); //ok</p>
<p>	int * b = new int;<br />
	shared_ptr sptr3(b);<br />
	shared_ptr sptr4(b); //WRONG!!</p>
<p>	return 0;<br />
}<br />
[/cpp] </a></p>
<p></body></html></p>
