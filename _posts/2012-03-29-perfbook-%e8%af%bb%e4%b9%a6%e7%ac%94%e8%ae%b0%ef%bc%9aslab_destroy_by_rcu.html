---
categories:
- Linux Kernel
date: 2012-03-29 22:15:50-07:00
layout: post
permalink: /2012/03/29/perfbook-%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0%ef%bc%9aslab_destroy_by_rcu/
title: perfbook 读书笔记：SLAB_DESTROY_BY_RCU
---
<p><br />

<p>perfbook 书中第8.3.3.6节讲到了类型安全，提到了Linux内核中的 SLAB_DESTROY_BY_RCU。但是书中并没有更详细的介绍这个特性。这里更详细地说一下。</p>
<p>要理解 SLAB_DESTROY_BY_RCU，最重要的是看 kmem_cache_destroy()，以 slub 为例，<br />
[c]<br />
void kmem_cache_destroy(struct kmem_cache *s)<br />
{<br />
        down_write(&amp;slub_lock);<br />
        s-&gt;refcount--;<br />
        if (!s-&gt;refcount) {<br />
                list_del(&amp;s-&gt;list);<br />
                up_write(&amp;slub_lock);<br />
                if (kmem_cache_close(s)) {<br />
                        printk(KERN_ERR "SLUB %s: %s called for cache that "<br />
                                "still has objects.n", s-&gt;name, __func__);<br />
                        dump_stack();<br />
                }<br />
                if (s-&gt;flags &amp; SLAB_DESTROY_BY_RCU)<br />
                        rcu_barrier();<br />
                sysfs_slab_remove(s);<br />
        } else<br />
                up_write(&amp;slub_lock);<br />
}<br />
[/c]</p>
<p>看那两行就足够了，rcu_barrier(); 是用来等待所有的 call_rcu() 回调函数结束，那么，kmem_cache_destroy() 在 SLAB_DESTROY_BY_RCU 的情况很明显就是等待所有 kmem_cache_free() 完成。</p>
<p>和普通的用 kmem_cache_alloc() 分配出来的对象相比，这种内存分配方式提供了更弱的保证，普通的分配可以保证对象不会被释放回 cache 中，而这个仅仅保证它不会被彻底释放，但不保证它会被放回 cache 重新利用，也就是说类型是不变的，即所谓的类型安全。实际上，在此期间它很有可能已经被放回 cache 重新利用了。</p>
<p>正是因为这种保证更弱了，所以在 rcu_read_lock() 并发区内就要多一个检查，检查是否还是之前的那个对象，因为这是类型安全的，所以对它进行同类型的检查是完全合法的。一个很好的例子是 __lock_task_sighand()：</p>
<p>[c]<br />
struct sighand_struct *__lock_task_sighand(struct task_struct *tsk,<br />
                                           unsigned long *flags)<br />
{<br />
        struct sighand_struct *sighand;</p>
<p>        for (;;) {<br />
                local_irq_save(*flags);<br />
                rcu_read_lock();<br />
                sighand = rcu_dereference(tsk-&gt;sighand);<br />
                if (unlikely(sighand == NULL)) {<br />
                        rcu_read_unlock();<br />
                        local_irq_restore(*flags);<br />
                        break;<br />
                }</p>
<p>                spin_lock(&amp;sighand-&gt;siglock);<br />
                if (likely(sighand == tsk-&gt;sighand)) {<br />
                        rcu_read_unlock();<br />
                        break;<br />
                }<br />
                spin_unlock(&amp;sighand-&gt;siglock);<br />
                rcu_read_unlock();<br />
                local_irq_restore(*flags);<br />
        }</p>
<p>        return sighand;<br />
}<br />
[/c]</p>
<p>注意，-&gt;siglock 是在 -&gt;ctor() 中初始化的，所以刚分配出来的 sighand 的 -&gt;siglock 也是已初始化的。</p>
<p>在此基础上，Linux 内核中还衍生出一个新的哈希链表，hlist_nulls，具体可以参考 Documentation/RCU/rculist_nulls.txt。</p>
<p></p>