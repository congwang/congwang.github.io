---
categories:
- Linux Kernel
date: 2012-11-17 22:03:14-08:00
layout: post
permalink: /2012/11/17/%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3-vxlan/
title: 深入理解 VXLAN
---
<p><br />
<br />
<a href="http://tools.ietf.org/html/draft-mahalingam-dutt-dcops-vxlan-02" target="_blank">VXLAN</a> 是非常新的一个 tunnel 技术，它是一个 L2 tunnel。Linux 内核的 upstream 中也刚刚加入 VXLAN 的实现。相比 GRE tunnel 它有着很的扩展性，同时解决了很多其它问题。</p>
<p><strong>一，GRE tunnel 的不足</strong></p>
<p>网络很多介绍 VXLAN 的文章都没有直接告诉你相比较 GRE tunnel，VXLAN 的优势在哪里，或者说 GRE tunnel 的不足在哪里。为了更好的了解 VXLAN，我们有必要看一下 GRE tunnel 的不足。</p>
<p>在我前面写的介绍 GRE tunnel 的文章中，其实并不容易看出 GRE tunnel 的不足之处。根本原因是图中给出的例子不太好，只有两个网络的话 GRE tunnel 的不足凸显不出来，让我们看看有三个网络的情况如何用 GRE tunnel 互联，如下图所示：</p>
<p style="text-align:center;"><a href="http://wangcong.org/blog/wp-content/uploads/2012/11/gre_vs_vxlan.jpg"><img class="aligncenter size-full wp-image-2171" src="{{site.baseurl}}/assets/2012/11/gre_vs_vxlan.jpg" alt="" width="675" height="513"></a></p>
<p>这下子就很明显了，要让这三个网络互联，我们需要建立三个 GRE tunnel。如果网络数量再增长，那么需要的 tunnel 数量更多。换句话说，GRE tunnel 的扩展性太差，从根本上讲还是因为它只是一个 point to point 的 tunnel。</p>
<p><strong>二，VLAN 的不足</strong></p>
<p>其实 VLAN 在某种程度上也可以看作一个 L2 over L2 的 tunnel，只不过它多了一个新的 VLAN header，这其中有12 bit 是 VLAN tag。所以 VLAN 的第一个不足之处就是它最多只支持 4096 个 VLAN 网络（当然这还要除去几个预留的），对于大型数据中心的来说，这个数量是远远不够的。</p>
<p>第二个不足就是，VLAN 这个所谓的 tunnel 是基于 L2 的，所以很难跨越 L2 的边界，在很大程度上限制了网络的灵活性。同时，VLAN 操作需手工介入较多，这对于管理成千上万台机器的管理员来说是难以接受的。</p>
<p><strong>三，VXLAN 的引入</strong></p>
<p>VXLAN 是 Virtual eXtensible LANs 的缩写，所以顾名思义，它是对 VLAN 的一个扩展，但又不仅限于此。</p>
<p>从数量上讲，它确实把 12 bit 的 VLAN tag 扩展成了 24 bit，所以至少暂时够用的了。从实现上讲，它是 L2 over UDP，它利用了 UDP 同时也是 IPv4 的单播和多播，可以跨 L3 边界，很巧妙地解决了 GRE tunnel 和 VLAN 存在的不足，让组网变得更加灵活。</p>
<p><strong>四，VXLAN 的实现</strong></p>
<p>VXLAN 的配置可以参考内核文档 Documentation/networking/vxlan.txt，本人目前还没有环境测试，所以只能做一些代码分析了。</p>
<p>Linux 内核中对 VXLAN 的实现是在 drivers/net/vxlan.c 源文件中，是由 Stephen Hemminger （iproute2 的维护者）完成的。代码质量相当高，所以可读性也很好，强烈推荐阅读一下。</p>
<p>看代码之前先看 VXLAN 的头是一个怎样的结构，如下图所示（图片来自参考资料4）：</p>
<p style="text-align:center;"><a href="http://wangcong.org/blog/wp-content/uploads/2012/11/VXLAN-Headers1.png"><img class="aligncenter size-full wp-image-2172" src="{{site.baseurl}}/assets/2012/11/VXLAN-Headers1.png" alt="" width="630" height="153"></a></p>
<p>好了，现在我们可以看代码了。先看发送端，vxlan_xmit() 函数。首先需要说的是发送之前内核会检查目的地址，如果是L2 multicast，那么应该发送到 VXLAN group 组播地址，否则，如果 MAC 地址是已知的，直接单播到对应的 IP；如果未知，则广播到组播地址。代码如下，比文档还要好读。:-)</p>
<p>[c]<br />
static __be32 vxlan_find_dst(struct vxlan_dev *vxlan, struct sk_buff *skb)<br />
{<br />
        const struct ethhdr *eth = (struct ethhdr *) skb-&gt;data;<br />
        const struct vxlan_fdb *f;</p>
<p>        if (is_multicast_ether_addr(eth-&gt;h_dest))<br />
                return vxlan-&gt;gaddr;</p>
<p>        f = vxlan_find_mac(vxlan, eth-&gt;h_dest);<br />
        if (f)<br />
                return f-&gt;remote_ip;<br />
        else<br />
                return vxlan-&gt;gaddr;</p>
<p>}<br />
[/c]</p>
<p>剩下的基本上就是一层一层的往外添加头了，依次添加 VXLAN header，UDP header，IP header：<br />
[c]<br />
//...<br />
        vxh = (struct vxlanhdr *) __skb_push(skb, sizeof(*vxh));<br />
        vxh-&gt;vx_flags = htonl(VXLAN_FLAGS);<br />
        vxh-&gt;vx_vni = htonl(vxlan-&gt;vni &lt;dest = htons(vxlan_port);<br />
        uh-&gt;source = htons(src_port);</p>
<p>        uh-&gt;len = htons(skb-&gt;len);<br />
        uh-&gt;check = 0;</p>
<p>        __skb_push(skb, sizeof(*iph));<br />
        skb_reset_network_header(skb);<br />
        iph             = ip_hdr(skb);<br />
        iph-&gt;version    = 4;<br />
        iph-&gt;ihl        = sizeof(struct iphdr) &gt;&gt; 2;<br />
        iph-&gt;frag_off   = df;<br />
        iph-&gt;protocol   = IPPROTO_UDP;<br />
        iph-&gt;tos        = vxlan_ecn_encap(tos, old_iph, skb);<br />
        iph-&gt;daddr      = dst;<br />
        iph-&gt;saddr      = fl4.saddr;<br />
        iph-&gt;ttl        = ttl ? : ip4_dst_hoplimit(&amp;rt-&gt;dst);</p>
<p>        vxlan_set_owner(dev, skb);</p>
<p>[/c]</p>
<p>正如 GRE tunnel，比较复杂的地方是在接收端。因为 VXLAN 利用了 UDP，所以它在接收的时候势必需要有一个 UDP server 在监听某个端口，这个是在 VXLAN 初始化的时候完成的，即 vxlan_init_net() 函数：</p>
<p>[c]<br />
static __net_init int vxlan_init_net(struct net *net)<br />
{<br />
	struct vxlan_net *vn = net_generic(net, vxlan_net_id);<br />
	struct sock *sk;<br />
	struct sockaddr_in vxlan_addr = {<br />
		.sin_family = AF_INET,<br />
		.sin_addr.s_addr = htonl(INADDR_ANY),<br />
	};<br />
	int rc;<br />
	unsigned h;</p>
<p>	/* Create UDP socket for encapsulation receive. */<br />
	rc = sock_create_kern(AF_INET, SOCK_DGRAM, IPPROTO_UDP, &amp;vn-&gt;sock);<br />
	if (rc sock-&gt;sk;<br />
	sk_change_net(sk, net);</p>
<p>	vxlan_addr.sin_port = htons(vxlan_port);</p>
<p>	rc = kernel_bind(vn-&gt;sock, (struct sockaddr *) &amp;vxlan_addr,<br />
			 sizeof(vxlan_addr));<br />
	if (rc sock = NULL;<br />
		return rc;<br />
	}</p>
<p>	/* Disable multicast loopback */<br />
	inet_sk(sk)-&gt;mc_loop = 0;</p>
<p>	/* Mark socket as an encapsulation socket. */<br />
	udp_sk(sk)-&gt;encap_type = 1;<br />
	udp_sk(sk)-&gt;encap_rcv = vxlan_udp_encap_recv;<br />
	udp_encap_enable();</p>
<p>	for (h = 0; h vni_list[h]);</p>
<p>	return 0;<br />
}<br />
[/c]</p>
<p>由此可见内核内部创建 socket 的 API 是sock_create_kern()，bind() 对应的是 kernel_bind()。注意到这里实现了一个hook，vxlan_udp_encap_recv()，这个正是接收端的主要代码。</p>
<p>发送端是一层一层往外填，那么接收端一定就是一层一层外里剥：</p>
<p>[c]<br />
	/* pop off outer UDP header */<br />
	__skb_pull(skb, sizeof(struct udphdr));</p>
<p>	/* Need Vxlan and inner Ethernet header to be present */<br />
	if (!pskb_may_pull(skb, sizeof(struct vxlanhdr)))<br />
		goto error;</p>
<p>	/* Drop packets with reserved bits set */<br />
	vxh = (struct vxlanhdr *) skb-&gt;data;<br />
	if (vxh-&gt;vx_flags != htonl(VXLAN_FLAGS) ||<br />
	    (vxh-&gt;vx_vni &amp; htonl(0xff))) {<br />
		netdev_dbg(skb-&gt;dev, "invalid vxlan flags=%#x vni=%#xn",<br />
			   ntohl(vxh-&gt;vx_flags), ntohl(vxh-&gt;vx_vni));<br />
		goto error;<br />
	}</p>
<p>	__skb_pull(skb, sizeof(struct vxlanhdr));</p>
<p>	/* Is this VNI defined? */<br />
	vni = ntohl(vxh-&gt;vx_vni) &gt;&gt; 8;<br />
	vxlan = vxlan_find_vni(sock_net(sk), vni);<br />
	if (!vxlan) {<br />
		netdev_dbg(skb-&gt;dev, "unknown vni %dn", vni);<br />
		goto drop;<br />
	}</p>
<p>	if (!pskb_may_pull(skb, ETH_HLEN)) {<br />
		vxlan-&gt;dev-&gt;stats.rx_length_errors++;<br />
		vxlan-&gt;dev-&gt;stats.rx_errors++;<br />
		goto drop;<br />
	}<br />
[/c]</p>
<p>在重新入栈之前还要做一些准备工作：</p>
<p>[c]<br />
	/* Re-examine inner Ethernet packet */<br />
	oip = ip_hdr(skb);<br />
	skb-&gt;protocol = eth_type_trans(skb, vxlan-&gt;dev);</p>
<p>	/* Ignore packet loops (and multicast echo) */<br />
	if (compare_ether_addr(eth_hdr(skb)-&gt;h_source,<br />
			       vxlan-&gt;dev-&gt;dev_addr) == 0)<br />
		goto drop;</p>
<p>	if (vxlan-&gt;learn)<br />
		vxlan_snoop(skb-&gt;dev, oip-&gt;saddr, eth_hdr(skb)-&gt;h_source);</p>
<p>	__skb_tunnel_rx(skb, vxlan-&gt;dev);<br />
	skb_reset_network_header(skb);<br />
	skb-&gt;ip_summed = CHECKSUM_NONE;<br />
[/c]</p>
<p>另外需要特别指出的是：1) 加入和离开组播地址是在 vxlan_open() 和 vxlan_stop() 中完成的；2) Linux 内核已经把 bridge 的 L2 learn 功能给抽出来了，所以 VXLAN 也实现了对 L2 地址的学习和转发：</p>
<p>[c]<br />
static const struct net_device_ops vxlan_netdev_ops = {<br />
	.ndo_init		= vxlan_init,<br />
	.ndo_open		= vxlan_open,<br />
	.ndo_stop		= vxlan_stop,<br />
	.ndo_start_xmit		= vxlan_xmit,<br />
	.ndo_get_stats64	= vxlan_stats64,<br />
	.ndo_set_rx_mode	= vxlan_set_multicast_list,<br />
	.ndo_change_mtu		= eth_change_mtu,<br />
	.ndo_validate_addr	= eth_validate_addr,<br />
	.ndo_set_mac_address	= eth_mac_addr,<br />
	.ndo_fdb_add		= vxlan_fdb_add,<br />
	.ndo_fdb_del		= vxlan_fdb_delete,<br />
	.ndo_fdb_dump		= vxlan_fdb_dump,<br />
};<br />
[/c]</p>
<p>附注：openvswitch 中的 VXLAN 的实现：<a href="http://openvswitch.org/pipermail/dev/2011-October/012051.html">http://openvswitch.org/pipermail/dev/2011-October/012051.html</a></p>
<p><strong>参考资料：</strong></p>
<p>1. http://tools.ietf.org/html/draft-mahalingam-dutt-dcops-vxlan-02<br />
2. http://blogs.cisco.com/datacenter/digging-deeper-into-vxlan/<br />
3. http://www.yellow-bricks.com/2012/11/02/vxlan-use-cases/<br />
4. http://www.borgcube.com/blogs/2011/11/vxlan-primer-part-1/<br />
5. http://www.borgcube.com/blogs/2012/03/vxlan-primer-part-2-lets-get-physical/<br />
6. http://it20.info/2012/05/typical-vxlan-use-case/</p>