---
layout: post
title: reentrant，thread-safe 和 async-signal-safe
date: 2009-01-21 23:18:42.000000000 -08:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Programming
tags: []
meta:
  _publicize_pending: '1'
  original_post_id: '506'
  _wp_old_slug: '506'
author:
  login: wangcong2015
  email: wangcong@rocketmail.com
  display_name: wangcong2015
  first_name: ''
  last_name: ''
permalink: "/2009/01/21/reentrant%ef%bc%8cthread-safe-%e5%92%8c-async-signal-safe/"
---
<p><!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"><br />
<html><body></p>
<p>先上定义吧，POSIX对它们的<a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/xbd_chap03.html" target="_blank">定义</a>分别是：</p>
<blockquote><p>
<strong>Reentrant Function</strong></p>
<p>A function whose effect, when called by two or more threads, is guaranteed to be as if the threads each executed the function one after another in an undefined order, even if the actual execution is interleaved.</p>
<p><strong>Thread-Safe</strong></p>
<p>A function that may be safely invoked concurrently by multiple threads. <em>Each function defined in the System Interfaces volume of IEEE Std 1003.1-2001 is thread-safe unless explicitly stated otherwise.</em></p>
<p><strong>Async-Signal-Safe Function</strong></p>
<p>A function that may be invoked, without restriction, from signal-catching functions. <em>No function is async-signal-safe unless explicitly described as such.</em>
</p></blockquote>
<p>可重入我们都清楚，顾名思义，就是可以重新进入，进一步讲就是，用相同的输入，每次调用函数一定会返回相同的结果。这就是可重入。<a href="http://en.wikipedia.org/wiki/Reentrant_(subroutine)" target="_blank">wikipedia上</a>有更严谨的定义：</p>
<blockquote><p>* Must hold no static (global) non-constant data.<br />
* Must not return the address to static (global) non-constant data.<br />
* Must work only on the data provided to it by the caller.<br />
* Must not rely on locks to singleton resources.<br />
* Must not call non-reentrant computer programs or routines.</p></blockquote>
<p>然后是<a href="http://en.wikipedia.org/wiki/Thread-safety" target="_blank">线程安全</a>，从定义上看，它仅要求了可以安全地被线程并发执行。这是一个相对较低的要求，因为它内部可以访问全局变量或静态变量，不过需要加锁，也就是说，只要是在线程可控之中的，每次调用它返回不同的结果也没关系。到这里我们可以看出：<strong>可重入函数一定是线程安全的，而反之未必。</strong>wikipedia上也写道：</p>
<blockquote><p>Therefore, reentrancy is a more fundamental property than thread-safety and by definition, leads to thread-safety: Every reentrant function is thread-safe, however, not every thread-safe function is reentrant.</p></blockquote>
<p>例子，有很多，最出名的莫过于strtok(3)，我们认识可重入这个概念就是从它开始的，它内部适用了静态变量，显然是不可重入的（它的可重入版是strtok_r(3)）。其次应该是malloc(3)，嘿嘿，其实也很明显，我就不多说了。但是，strtok(3)<strong>不是</strong>线程安全的，而malloc(3)是。</p>
<p>还有一个概念我们不常碰到，那就是异步信号安全，它其实也很简单，就是一个函数可以在信号处理函数中被安全地调用。看起来它似乎和线程安全类似，其实不然，我们知道信号是异步产生的，但是，信号处理函数是打断主函数（相对于信号处理函数）后执行，执行完后又返回主函数中去的。也就是说，它<strong>不是</strong>并发的！</p>
<p>一个函数，它访问了全局变量，那么它就是不可重入的，不过我们可以把它变成线程安全的，加上锁就可以，但是这种方法并不会把它变成异步信号安全的，而几乎可以肯定的是，使用了锁的一定不是信号安全的（除非屏蔽了信号，显然），信号完全可以在锁加上后解开前到来，然后就很可能形成死锁…… <a href="http://www.cocoadev.com/index.pl?SignalSafety" target="_blank">这里</a>有个很好的例子。所以，可重入的函数也一定是异步信号安全的，而反之未必。可以参考<a href="http://www.ibm.com/developerworks/linux/library/l-reent.html" target="_blank">IBM上一篇不错的文章</a>。</p>
<p>关于异步信号安全的函数列表可以参考<a href="http://www.kernel.org/doc/man-pages/online/pages/man7/signal.7.html" target="_blank">man 7 signal</a>；关于<strong>非</strong>线程安全的函数列表可以参考<a href="http://book.chinaunix.net/special/ebook/addisonWesley/APUE2/0201433079/ch12lev1sec5.html" target="_blank">APUE第12.5节</a> ；关于可重入函数列表，可参考<a href="http://book.chinaunix.net/special/ebook/addisonWesley/APUE2/0201433079/ch10lev1sec6.html#ch10lev1sec6" target="_blank">APUE第10.6节</a>。另请<a href="http://www.unix.org/whitepapers/reentrant.html" target="_blank">参阅</a>。</body></html></p>
