---
categories:
- Programming
date: 2011-10-18 11:41:30-07:00
layout: post
permalink: /2011/10/18/shell-%e9%87%8d%e5%ae%9a%e5%90%91%e7%9a%84%e4%b8%80%e5%a4%84%e5%a6%99%e7%94%a8/
title: shell 重定向的一处妙用
---
<p><br />

<p>偶然在 dracut 的代码中发现一个使用重定向很巧妙的地方。见 modules.d/90kernel-modules/module-setup.sh 文件。</p>
<p>之前的老代码是这样的：</p>
<p>[bash]<br />
##<br />
             local _f<br />
             while read _f; do case "$_f" in<br />
                 *.ko)    [[ $(&lt;         $_f) =~ $_blockfuncs ]] &amp;&amp; echo "$_f" ;;<br />
                 *.ko.gz) [[ $(gzip -dc &lt;$_f) =~ $_blockfuncs ]] &amp;&amp; echo "$_f" ;;<br />
                 esac<br />
             done<br />
[/bash]</p>
<p>意思很清楚吧？就是在内核模块（注意是二进制格式）中匹配一些函数（字符串）。这样会很慢，因为 bash 要在庞大的二进制文件流中匹配一些指定字符串。</p>
<p>于是，就有人想了一个方法加速这个处理过程，把原来的单个数据流分成两个并行的数据流，同时进行匹配！很巧妙！</p>
<p>[bash]<br />
##<br />
             function bmf1() {<br />
                 local _f<br />
                 while read _f; do case "$_f" in<br />
                     *.ko)    [[ $(&lt;         $_f) =~ $_blockfuncs ]] &amp;&amp; echo "$_f" ;;<br />
                     *.ko.gz) [[ $(gzip -dc &amp;${side2}; fi<br />
                 done<br />
                 | bmf1     1&gt;&amp;${merge}    ) {side2}&gt;&amp;1<br />
                 | bmf1  )      {merge}&gt;&amp;1<br />
[/bash]</p>
<p>经过 refactor 之后的或许更好理解一些：</p>
<p>[bash]<br />
            # subfunctions inherit following FDs<br />
            local _merge=8 _side2=9<br />
            function bmf1() {<br />
                local _f<br />
                while read _f; do case "$_f" in<br />
                    *.ko)    [[ $(&lt;         $_f) =~ $_blockfuncs ]] &amp;&amp; echo "$_f" ;;<br />
                    *.ko.gz) [[ $(gzip -dc &amp;${_side2}<br />
                    fi<br />
                done | bmf1 1&gt;&amp;${_merge}<br />
            }<br />
            # Use two parallel streams to filter alternating modules.<br />
            eval "( ( rotor ) ${_side2}&gt;&amp;1 | bmf1 ) ${_merge}&gt;&amp;1"</p>
<p>[/bash] </p>
<p></p>