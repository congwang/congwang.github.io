---
layout: post
title: 尾部调用优化
date: 2009-03-23 20:14:46.000000000 -07:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Linux Kernel
tags: []
meta:
  _publicize_pending: '1'
  original_post_id: '649'
  _wp_old_slug: '649'
author:
  login: wangcong2015
  email: wangcong@rocketmail.com
  display_name: wangcong2015
  first_name: ''
  last_name: ''
permalink: "/2009/03/23/%e5%b0%be%e9%83%a8%e8%b0%83%e7%94%a8%e4%bc%98%e5%8c%96/"
---
<p><!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"><br />
<html><body></p>
<p>gcc实在是太聪明了，有时候就会聪明过头，尾部调用优化就是一个很好的例子。:)</p>
<p>尾部调用其实很好理解，就是在函数的最后调用另外一个函数，一种大的可能就是这个函数和调用函数参数差别很小，那么这时候，gcc会对这个尾部调用进行优化，如果可能，完全可以把调用那个函数时的入栈操作给直接优化掉。这就是尾部调用的优化。我们可以看看下面的例子：</p>
<p>[c]<br />
extern int callee(int a, int b);</p>
<p>static int c;</p>
<p>int call(int a, int b)<br />
{<br />
        int ret = callee(c, b);<br />
        return ret;<br />
}<br />
[/c]</p>
<p>用"gcc -fomit-frame-pointer -fno-inline -O2 -S tail_call.c"编译它，得到的汇编代码截取如下：</p>
<pre>
call:
        movl    c, %eax
        movl    %eax, 4(%esp)
        jmp     callee
</pre>
<p>很明显，入栈操作被优化掉了，成了直接操作call()的参数！这会有问题，如果call()的调用函数不想看到堆栈被改变的话。</p>
<p>在Linux内核中有个很好的例子，那就是系统调用！系统调用的入口（arch/x86/kernel/entry_32.S）是用汇编写成的，在进入一个系统调用前存放参数的寄存器会被入栈，系统调用完毕后又会被恢复，所以，如果系统调用也被做了尾部调用优化的话，那么系统调用前后寄存器的值就会发生变化！这就可能会破坏用户空间的代码！</p>
<p>Linux内核采取了相应的办法来解决这个问题，那就是宏asmlinkage_protect()，它的定义在arch/x86/include/asm/linkage.h。我们通过个具体的例子来看，比如open(2)，其定义是这样的：</p>
<p>[c]<br />
SYSCALL_DEFINE3(open, const char __user *, filename, int, flags, int, mode)<br />
{<br />
        long ret;</p>
<p>        if (force_o_largefile())<br />
                flags |= O_LARGEFILE;</p>
<p>        ret = do_sys_open(AT_FDCWD, filename, flags, mode);<br />
        /* avoid REGPARM breakage on x86: */<br />
        asmlinkage_protect(3, ret, filename, flags, mode);<br />
        return ret;<br />
}<br />
[/c]</p>
<p>上面的asmlinkage_protect会被展开成：</p>
<pre>
__asm__ __volatile__ ("" : "=r" (ret) : "0" (ret), "g" (filename),
                                                       "g" (flags), "g" (mode));
</pre>
<p>这句不会直接生成任何汇编代码，但是它会强迫gcc把参数放到寄存器中，也就避免了上面展示的直接对栈进行操作。</p>
<p>为了完整，我们把最开始的那段代码修复一下：<br />
[c]<br />
extern int callee(int a, int b);</p>
<p>static int c;</p>
<p>int call(int a, int b)<br />
{<br />
        int ret = callee(c, b);<br />
        __asm__("":"=r"(ret):"0"(ret), "g"(a), "g"(b));<br />
        return ret;<br />
}<br />
[/c]<br />
再汇编就可以看到堆栈操作了：</p>
<pre>
call:
        pushl   %ebx
        subl    $8, %esp
        movl    c, %eax
        movl    20(%esp), %ebx
        movl    %eax, (%esp)
        movl    %ebx, 4(%esp)
        call    callee
        addl    $8, %esp
        popl    %ebx
        ret
</pre>
<p>这里展示的代码都很简单，实际中往往很复杂，情况不同gcc的优化操作也不同，比如，当上面的callee()是static的时候虽然也会被优化但不会直接操作堆栈（而是通过使用寄存器），因为gcc可以完整地看到两个函数，可以在“全局”进行优化。实际问题实际分析，但这个尾部调用优化带来的问题我们必须得小心才是。</body></html></p>
