---
layout: post
title: UNP卷一读书笔记（一）
date: 2007-09-18 14:54:44.000000000 -07:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Programming
tags: []
meta:
  _publicize_pending: '1'
  original_post_id: '215'
  _wp_old_slug: '215'
author:
  login: wangcong2015
  email: wangcong@rocketmail.com
  display_name: wangcong2015
  first_name: ''
  last_name: ''
permalink: "/2007/09/18/unp%e5%8d%b7%e4%b8%80%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0%ef%bc%88%e4%b8%80%ef%bc%89/"
---
<p><!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"><br />
<html><body>
<p>1. inet_addr()是遗弃的函数，最好不要使用，因为它不能很好地处理错误。ping 255.255.255.255就是由此引发的问题，<br />
因为inet_addr()会把255.255.255.255当成-1！</p>
<p>2. inet_ntoa()使用的是静态缓冲区，因此不是线程安全的函数。而且，inet_ntoa()使用一个结构体类型做参数，而不是指向该结构体的指针。这种情况很少见。</p>
<p>3. 系统调用被中断的一个例子：当父进程在等待accept()时，收到了子进程死亡的信号SIGCHLD，而转去处理这个信号。<br />
此时如果不做处理，系统可能会自动重启这个系统调用，也可能会返回错误EINTR。</p>
<p>4. SIGKILL和SIGSTOP是不能被捕捉的，也不能被忽略。</p>
<p>5. UNIX文件中的change time和modification time不是一个概念。 如果我们使用`chmod a-w myfile'，这是一个change；如果我们用`echo foo &gt;&gt; myfile'，那这是一个modification。change修改的是文件的inode；而modification修改的是文件本身的内容。 文件的modification time也被称为时间戳（timestamp）。只读取文件会改变文件的access time，但不会改变上面提到的两个时间。</p>
<p>6. POSIX规定，select的第5个参数应该是const的，但Linux并未这样实现。Linux会修改这个struct timeval，来反映没有睡眠的时间。</p>
<p>7. 收到FIN之后，进程仍然可以向该socket写数据，但会收到一个RST。如果一个进程在收到RST之后，仍然向此socket里写数据，它就会收到一个SIGPIPE信号。该信号的默认处理方式是终止这个进程。所以进程必须能够捕捉到这个信号来避免意外的终止。如果进程捕捉到该信号并返回，或者直接忽略这个信号，写操作会返回一个EPIPE。通过第一次写操作，而不是第二次，是不可能得到SIGPIPE信号的。</p>
<p></body></html></p>
