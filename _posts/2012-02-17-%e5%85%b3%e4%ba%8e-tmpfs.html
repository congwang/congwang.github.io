---
layout: post
title: 关于 tmpfs
date: 2012-02-17 10:34:12.000000000 -08:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Linux Kernel
tags: []
meta:
  _publicize_pending: '1'
  original_post_id: '1887'
  _wp_old_slug: '1887'
author:
  login: wangcong2015
  email: wangcong@rocketmail.com
  display_name: wangcong2015
  first_name: ''
  last_name: ''
permalink: "/2012/02/17/%e5%85%b3%e4%ba%8e-tmpfs/"
---
<p><!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"><br />
<html><body></p>
<p>"tmpfs" 是 Linux 内核中另一个让人困惑的名字，它的实现是在 mm/shmem.c，"shmem" 猛一看和 "tmpfs" 根本不沾边，虽然我们知道 tmpfs 是基于内存的！我们可以通过看一下 tmpfs 都被用到哪些地方来了解它到底为什么叫这个名字。</p>
<p>你的桌面 Linux 系统中基本上都会挂载了 tmpfs：</p>
<p>% grep tmpfs /proc/mounts<br />
devtmpfs /dev devtmpfs rw,seclabel,nosuid,relatime,size=1958956k,nr_inodes=489739,mode=755 0 0<br />
<strong>tmpfs /dev/shm tmpfs rw,seclabel,nosuid,nodev,relatime 0 0</strong><br />
tmpfs /run tmpfs rw,seclabel,nosuid,nodev,relatime,mode=755 0 0<br />
tmpfs /sys/fs/cgroup tmpfs rw,seclabel,nosuid,nodev,noexec,relatime,mode=755 0 0<br />
tmpfs /media tmpfs rw,rootcontext=system_u:object_r:mnt_t:s0,seclabel,nosuid,nodev,noexec,relatime,mode=755 0 0</p>
<p>正如<a href="http://wangcong.org/blog/archives/591">这篇文章</a>中提到的，/dev/shm 是 POSIX IPC 用到的，用来实现进程间通信。除了 sem_open(3) 的中 oflag 参数，基本上看不出来和文件有什么相关。</p>
<p>除此之外，另一个用到它的地方是 anonymous shared mapping！</p>
<pre>
mmap_region():

        if (file) {
        //...
        } else if (vm_flags &amp; VM_SHARED) {
                error = shmem_zero_setup(vma);
                if (error)
                        goto free_vma;
        }
</pre>
<p>shmem_zero_setup() 在内核通过 kern_mount() 挂载的（用户不可见的） tmpfs 的根目录中创建了一个"dev/zero"的文件，注意，这里可以重复创建哦，因为内核跳过了类似 may_create() 的检查，而且这个文件本身很特殊，它一开始就是 unlinked 的。所以内核实际上是通过 tmpfs 中的一个文件来实现了匿名的共享映射！到此，你可以看出，tmpfs 这个名字其实名副其实了。</p>
<p>另外，tmpfs 本身可以随意挂载，通过 mount -t tmpfs，你可以在上面进行任意文件操作。所以，内核通过 tmpfs 一套代码把下面三个东西给统一起来了：1. 匿名共享映射；2. POSIX IPC；3. tmpfs 文件操作。Mel Gorman <a href="http://kernel.org/doc/gorman/html/understand/understand015.html">这样解释</a>到：</p>
<blockquote><p>This is a very clean interface that is conceptually easy to understand but it does not help anonymous pages as there is no file backing. To keep this nice interface, Linux creates an artifical file-backing for anonymous pages using a RAM-based filesystem where each VMA is backed by a “file” in this filesystem. Every inode in the filesystem is placed on a linked list called shmem_inodes so that they may always be easily located. This allows the same file-based interface to be used without treating anonymous pages as a special case.</p></blockquote>
<p>之所以用 tmpfs 而不是同样基于内存的 ramfs 是因为：1) tmpfs 文件是可以 swap 的；2) tmpfs 是有大小限制的，不会允许用户无限制使用内存从而导致 OOM。（注：只有当 CONFIG_SHMEM=n 时，tmpfs 才会调用 ramfs 代码。）</body></html></p>
