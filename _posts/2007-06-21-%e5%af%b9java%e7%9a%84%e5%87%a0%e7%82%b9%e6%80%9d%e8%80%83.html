---
categories:
- Programming
date: 2007-06-21 23:23:10-07:00
layout: post
permalink: /2007/06/21/%e5%af%b9java%e7%9a%84%e5%87%a0%e7%82%b9%e6%80%9d%e8%80%83/
title: 对Java的几点思考
---
<p><br />

<p>1. 符号带来的问题</p>
<p>我们知道，Java里的整数类型——byte，short，int——全部是有符号的。这有时会带来麻烦，如果我们并不想要最高位作为符号位的话。</p>
<p>下面是两个例子：</p>
<p>a) 我们不得不这样做来正确显示IP地址：</p>
<p>byte[] ipa;<br />
InetAddress ina = CmdSocket.getLocalAddress();<br />
ipa = ina.getAddress();<br />
for (int i=0; i&lt; 4; i++) {<br />
System.out.println(((int)ipa[i]) &amp; 0xff);<br />
}</p>
<p>b) 记住，char是无符号的：[1]</p>
<p>public class Multicast {<br />
public static void main(String[] args) {<br />
System.out.println((int) (char) (byte) -1);<br />
}<br />
}</p>
<p>2. 类型问题</p>
<p>Java在处理类型之间转化时有着自己的规则，这些规则有时并不好理解。</p>
<p>a. 转化[2]</p>
<p>short x = 0;<br />
int i = 123456;<br />
x += i;<br />
x = x + i; //&lt;== fails here</p>
<p>b. 溢出[3]</p>
<p>public class LongDivision {<br />
public static void main(String[] args) {<br />
final long MICROS_PER_DAY = 24 * 60 * 60 * 1000 * 1000;<br />
final long MILLIS_PER_DAY = 24 * 60 * 60 * 1000;<br />
System.out.println(MICROS_PER_DAY / MILLIS_PER_DAY);<br />
}<br />
}</p>
<p>3. 读文件的问题</p>
<p>Java中有各种各样的流，这使得选取恰当的流并不容易。有时，我们为了得到一个理想的流，不得不转化多次：</p>
<p>BufferedOutputStream FTPOutStream;<br />
FTPOutStream = new BufferedOutputStream((OutputStream)System.out);<br />
BufferedInputStream FTPInStream;<br />
FTPInStream = new BufferedInputStream(new FileInputStream(LocalFile));</p>
<p>而且，Java中的DataInputStream流并不像想象中那么好，根本原因是：readInt()并不认识int，它只管读下面4个字节，并不在乎它这四个到底是什么，即使在文本中它们看起来可能只是几个非数字的字符！同样，readLong不认识long，readDouble()也不认识double。而这一点，C++和C做得明显要更好。</p>
<p>Scanner或许可以帮上一些忙，不过很可惜，你不能用它读一个char！</p>
<p>---</p>
<p>参考资料：</p>
<p>[1][2][3]均摘自《Java Puzzlers》<br />
[4]《Java Language Specification》</p>
<p></p>