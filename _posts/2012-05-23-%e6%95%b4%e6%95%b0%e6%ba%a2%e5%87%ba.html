---
layout: post
title: 整数溢出
date: 2012-05-23 13:46:25.000000000 -07:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Programming
tags: []
meta:
  _publicize_pending: '1'
  original_post_id: '1986'
  _wp_old_slug: '1986'
author:
  login: wangcong2015
  email: wangcong@rocketmail.com
  display_name: wangcong2015
  first_name: ''
  last_name: ''
permalink: "/2012/05/23/%e6%95%b4%e6%95%b0%e6%ba%a2%e5%87%ba/"
---
<p><!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"><br />
<html><body></p>
<p>整数溢出大家都不陌生，可能陌生的是 gcc 对带符号整数溢出的处理。</p>
<p>先看标准怎么说，对于无符号整数，标准如此描述：</p>
<blockquote><p>A computation involving unsigned operands can never overflow,<br />
because a result that cannot be represented by the resulting unsigned<br />
integer type is reduced modulo the number that is one greater than the<br />
largest value that can be represented by the resulting type.</p></blockquote>
<p>换句话说，无符号整数的溢出总是 wrap 回去的，但依旧在无符号整数的表示范围内。</p>
<p>对于带符号整数的溢出，标准规定是未定义行为：</p>
<blockquote><p>If an exceptional condition occurs during the evaluation of an expression (that is, if the<br />
result is not mathematically defined or not in the range of representable values for its<br />
 type), the behavior is undefined.</p></blockquote>
<p>实际上（使用二进制补码），如果溢出的话，两个正数结果会变成负数，超出了正数本身的范围。wikipedia 中如此说：</p>
<blockquote><p>Most computers distinguish between two kinds of overflow conditions. A carry occurs when the result of an addition or subtraction, considering the operands and result as unsigned numbers, does not fit in the result. Therefore, it is useful to check the carry flag after adding or subtracting numbers that are interpreted as unsigned values. An overflow proper occurs when the result does not have the sign that one would predict from the signs of the operands (e.g. a negative result when adding two positive numbers). Therefore, it is useful to check the overflow flag after adding or subtracting numbers that are represented in two's complement form (i.e. they are considered signed numbers).</p></blockquote>
<p>正是因为“未定义”，所以 gcc 会大胆地做出一些可能令你吃惊的优化。看下面的例子：</p>
<p>[c]<br />
#include<br />
#include </p>
<p>int wrap(int a) {<br />
  return (a + 1 &gt; a);<br />
}</p>
<p>int main(void) {<br />
  printf("%sn", wrap(INT_MAX) ? "no wrap" : "wrapped");<br />
}<br />
[/c]</p>
<p>很好理解，可是 gcc 完全可以如此生成 wrap() 函数的代码：</p>
<p>00000000004004f0 :<br />
  4004f0:       b8 01 00 00 00          mov    $0x1,%eax<br />
  4004f5:       c3                      retq</p>
<p>因为 gcc 假设了带符号的整数从来不会溢出，所以"a + 1 &gt; a" 总会是真，所以直接返回1！这么做完全符合标准，但不符合我们的期待。我们期望 wrap() 函数能够检测是否会溢出。</p>
<p>为此，gcc 引入了几个相关的命令行选项：-fwrapv，-fstrict-overflow/-fno-strict-overflow，-Wstrict-overflow。简单地说，-fstrict-overflow 就是告诉编译器，带符号整数溢出是未定义的，你可以假设它不会发生，从而继续做优化。而 -fwrapv 是说，带符号整数的溢出是定义好的，就是 wrap，你按照这个定义来编译。gcc 文档中提到：</p>
<blockquote><p>Using -fwrapv means that integer signed overflow is fully defined: it wraps.  When -fwrapv is used, there is no difference between -fstrict-overflow and -fno-strict-overflow for integers.  With -fwrapv certain types of overflow are permitted. For example, if the compiler gets an overflow when doing arithmetic on constants, the overflowed value can still be used with fwrapv, but not otherwise.</p></blockquote>
<p>我们加上 -fno-strict-overflow 之后再去编译上面的代码，结果明显不同：</p>
<p>00000000004004f0 :<br />
  4004f0:       8d 47 01                lea    0x1(%rdi),%eax<br />
  4004f3:       39 f8                   cmp    %edi,%eax<br />
  4004f5:       0f 9f c0                setg   %al<br />
  4004f8:       0f b6 c0                movzbl %al,%eax<br />
  4004fb:       c3                      retq</p>
<p>而对于使用二进制补码的机器来说，-fwrapv 和 -fno-strict-overflow 只有细微的区别： -fno-strict-overflow 只是说不去优化，而-fwrapv 明确地定义了溢出的行为。</p>
<p>Linux 内核中曾经出现一个<a href="https://lkml.org/lkml/2009/7/12/92">相关的 bug</a>，是 Linus 大神出手搞定了，他说道：</p>
<blockquote><p>
It looks like 'fwrapv' generates more temporaries (possibly for the code<br />
that treies to enforce the exact twos-complement behavior) that then all<br />
get optimized back out again. The differences seem to be in the temporary<br />
variable numbers etc, not in the actual code.</p>
<p>So fwrapv really _is_ different from fno-strict-pverflow, and disturbs the<br />
code generation more.</p>
<p>IOW, I'm convinced we should never use fwrapv. It's clearly a buggy piece<br />
of sh*t, as shown by our 4.1.x experiences. We should use<br />
-fno-strict-overflow.</p></blockquote>
<p>所以编译 Linux 内核时使用的是 -fno-strict-overflow。<br />
</body></html></p>
