---
layout: post
title: Python heapq 模块的实现
date: 2012-06-10 22:07:01.000000000 -07:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Programming
tags: []
meta:
  _publicize_pending: '1'
  original_post_id: '2013'
  _wp_old_slug: '2013'
author:
  login: wangcong2015
  email: wangcong@rocketmail.com
  display_name: wangcong2015
  first_name: ''
  last_name: ''
permalink: "/2012/06/10/python-heapq-%e6%a8%a1%e5%9d%97%e7%9a%84%e5%ae%9e%e7%8e%b0/"
---
<p><!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"><br />
<html><body>
<p>无意间看了一下 Python heapq 模块的源代码，发现里面的源代码写得很棒，忍不住拿出来和大家分享一下。:)</p>
<p>heapq 的意思是 heap queue，也就是基于 heap 的 <a href="http://en.wikipedia.org/wiki/Priority_queue">priority queue</a>。说到 priority queue，忍不住吐槽几句。我上学的时候学优先级队列的时候就没有碰到像 wikipedia 上那样透彻的解释，priority queue 并不是具体的某一个数据结构，而是对一类数据结构的概括！比如栈就可以看作是后进入的优先级总是大于先进入的，而队列就可以看成是先进入的优先级一定高于后进来的！这还没完！如果我们是用一个无序的数组实现一个priority queue，对它进行出队操作尼玛不就是选择排序么！尼玛用有序数组实现入队操作尼玛不就是插入排序么！尼玛用堆实现（即本文要介绍的）就是堆排序啊！用二叉树实现就是二叉树排序啊！数据结构课学的这些东西基本上都出来了啊！T_T</p>
<p><a href="http://hg.python.org/cpython/file/2.7/Lib/heapq.py">heapq 的代码</a>也是用 Python 写的，用到了一些其它 Python 模块，如果你对 itertools 不熟悉，在阅读下面的代码之前<a href="http://docs.python.org/library/itertools.html">请先读文档</a>。heapq 模块主要有5个函数：heappush()，把一个元素放入堆中；heappop()，从堆中取出一个元素；heapify()，把一个列表变成一个堆；nlargest() 和 nsmallest() 分别提供列表中最大或最小的N个元素。</p>
<p>先从简单的看起：</p>
<p>[python]<br />
def heappush(heap, item):<br />
    """Push item onto heap, maintaining the heap invariant."""<br />
    heap.append(item)<br />
    _siftdown(heap, 0, len(heap)-1)</p>
<p>def heappop(heap):<br />
    """Pop the smallest item off the heap, maintaining the heap invariant."""<br />
    lastelt = heap.pop()    # raises appropriate IndexError if heap is empty<br />
    if heap:<br />
        returnitem = heap[0]<br />
        heap[0] = lastelt<br />
        _siftup(heap, 0)<br />
    else:<br />
        returnitem = lastelt<br />
    return returnitem<br />
[/python]</p>
<p>从源代码我们不难看出，这个堆也是用数组实现的，而且是最小堆，即 a[k] &lt;= a[2*k+1] and a[k]  startpos:<br />
        parentpos = (pos - 1) &gt;&gt; 1<br />
        parent = heap[parentpos]<br />
        if cmp_lt(newitem, parent):<br />
            heap[pos] = parent<br />
            pos = parentpos<br />
            continue<br />
        break<br />
    heap[pos] = newitem</p>
<p>def _siftup(heap, pos):<br />
    endpos = len(heap)<br />
    startpos = pos<br />
    newitem = heap[pos]<br />
    # Bubble up the smaller child until hitting a leaf.<br />
    childpos = 2*pos + 1    # leftmost child position<br />
    while childpos &lt; endpos:<br />
        # Set childpos to index of smaller child.<br />
        rightpos = childpos + 1<br />
        if rightpos &lt; endpos and not cmp_lt(heap[childpos], heap[rightpos]):<br />
            childpos = rightpos<br />
        # Move the smaller child up.<br />
        heap[pos] = heap[childpos]<br />
        pos = childpos<br />
        childpos = 2*pos + 1<br />
    # The leaf at pos is empty now.  Put newitem there, and bubble it up<br />
    # to its final resting place (by sifting its parents down).<br />
    heap[pos] = newitem<br />
    _siftdown(heap, startpos, pos)<br />
[/python]</p>
<p>上面的代码加上注释很容易理解，不是吗？在此基础上实现 heapify() 就很容易了：</p>
<p>[python]<br />
def heapify(x):<br />
    """Transform list into a heap, in-place, in O(len(x)) time."""<br />
    n = len(x)<br />
    # Transform bottom-up.  The largest index there's any point to looking at<br />
    # is the largest with a child index in-range, so must have 2*i + 1 &lt; n,<br />
    # or i &lt; (n-1)/2.  If n is even = 2*j, this is (2*j-1)/2 = j-1/2 so<br />
    # j-1 is the largest, which is n//2 - 1.  If n is odd = 2*j+1, this is<br />
    # (2*j+1-1)/2 = j so j-1 is the largest, and that's again n//2-1.<br />
    for i in reversed(xrange(n//2)):<br />
        _siftup(x, i)<br />
[/python]<br />
这里用了一个技巧，正如注释中所说，其实只要 siftup 后面一半就可以了，前面的一半自然就是一个heap了。heappushpop() 也可以用它来实现了，而且用不着调用 heappush()+heappop()：</p>
<p>[python]<br />
def heappushpop(heap, item):<br />
    """Fast version of a heappush followed by a heappop."""<br />
    if heap and cmp_lt(heap[0], item):<br />
        item, heap[0] = heap[0], item<br />
        _siftup(heap, 0)<br />
    return item<br />
[/python]</p>
<p>第一眼看到这个函数可能觉得它放进去一个再取出来一个有什么意思嘛！仔细想想它很有用，尤其是在后面实现 nlargest() 的时候：</p>
<p>[python]<br />
def nlargest(n, iterable):<br />
    """Find the n largest elements in a dataset.</p>
<p>    Equivalent to:  sorted(iterable, reverse=True)[:n]<br />
    """<br />
    if n &lt; 0:<br />
        return []<br />
    it = iter(iterable)<br />
    result = list(islice(it, n))<br />
    if not result:<br />
        return result<br />
    heapify(result)<br />
    _heappushpop = heappushpop<br />
    for elem in it:<br />
        _heappushpop(result, elem)<br />
    result.sort(reverse=True)<br />
    return result<br />
[/python]</p>
<p>先从 list 中取出 N 个元素来，然后把这个 list 转化成 heap，把原先的 list 中的所有元素在此 heap 上进行 heappushpop() 操作，最后剩下的一定是最大的！因为你每次 push 进去的不一定是最大的，但你 pop 出来的一定是最小的啊！</p>
<p>但 nsmallest() 的实现就截然不同了：</p>
<p>[python]<br />
def nsmallest(n, iterable):<br />
    """Find the n smallest elements in a dataset.</p>
<p>    Equivalent to:  sorted(iterable)[:n]<br />
    """<br />
    if n &lt; 0:<br />
        return []<br />
    if hasattr(iterable, '__len__') and n * 10  Largest of the nsmallest<br />
        for elem in it:<br />
            if cmp_lt(elem, los):<br />
                insort(result, elem)<br />
                pop()<br />
                los = result[-1]<br />
        return result<br />
    # An alternative approach manifests the whole iterable in memory but<br />
    # saves comparisons by heapifying all at once.  Also, saves time<br />
    # over bisect.insort() which has O(n) data movement time for every<br />
    # insertion.  Finding the n smallest of an m length iterable requires<br />
    #    O(m) + O(n log m) comparisons.<br />
    h = list(iterable)<br />
    heapify(h)<br />
    return map(heappop, repeat(h, min(n, len(h))))<br />
[/python]</p>
<p>这里做了一个优化，如果 N 小于 list 长度的1/10的话，就直接用插入排序（因为之前就是有序的，所以很快）。如果 N 比较大的话，就用 heap 来实现了，把整个 list 作成一个堆，然后 heappop() 出来的前 N 个就是最后的结果了！不得不说最后一行代码写得太精炼了！</p>
<p></body></html></p>
