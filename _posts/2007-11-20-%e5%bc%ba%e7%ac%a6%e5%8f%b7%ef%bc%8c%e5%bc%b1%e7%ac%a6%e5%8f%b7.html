---
categories:
- Programming
date: 2007-11-20 22:05:43-08:00
layout: post
permalink: /2007/11/20/%e5%bc%ba%e7%ac%a6%e5%8f%b7%ef%bc%8c%e5%bc%b1%e7%ac%a6%e5%8f%b7/
title: 强符号，弱符号
---
<p><br />
</p>
<p>对于链接器来说，所有的全局符号可分为两种：强符号（Strong symbols），弱符号（Weak symbols）。gcc的attribute中有个__attribute__((weak))，就是用来声明这个符号是弱符号的。gcc手册中这样写道：</p>
<blockquote><p>The weak attribute causes the declaration to be emitted as a weak symbol rather than a global. This is primarily useful in defining <strong>library functions</strong> which can be overridden in user code, though it can also be used with non-function declarations. Weak symbols are supported for ELF targets, and also for a.out targets when using the GNU assembler and linker.</p></blockquote>
<p>对于这个gcc扩展，<a href="http://www.cs.virginia.edu/~wh5a/blog/2006/07/20/the-weak-attribute-of-gcc/">这里</a>作了一个简洁的介绍。我们来看更通用的情况。;)</p>
<p>一般来说，函数和已初始化的变量是强符号，而未初始化的变量是弱符号。对于它们，下列三条规则适用：</p>
<p>1.  同名的强符号只能有一个。<br />
2. 有一个强符号和多个同名的弱符号是可以的，但定义会选择强符号的。<br />
3. 有多个弱符号时，链接器可以选择其中任意一个。</p>
<p>这三条规则看起来很好理解，其实不然，尤其是当这些弱符号类型和强符号不同时！表面上看起来正确的程序会导致严重的错误！考虑下面这个<a href="http://www.cs.cmu.edu/afs/cs.cmu.edu/academic/class/15213-f06/www/lectures/class13.pdf">csapp中</a>的例子：</p>
<p>===a.c===<br />
int x=7;<br />
int y=5;<br />
p1() {}</p>
<p>===b.c===<br />
double x;<br />
p2() {}</p>
<p>我们把它们一起编译，并且在p2()函数中给x赋值，你会发现，y也改变了！ 虽然x被看作是double，但其定义会取a.c中的int x，也就是说，在b.c中会把a.c中的int x当double来用！这当然是错误！之所以会这样，就是因为上面的规则2。避免这种错误的一个方法是，给gcc加上-fno-common选项。</p>
<p>关于弱符号，man手册中这样解释到：</p>
<blockquote><p>When a weak defined symbol is linked with a normal defined  symbol, the  normal defined symbol is used with no error.  When a weak undefined symbol is linked and the symbol is not defined, the value of the weak symbol becomes zero with no error.</p></blockquote>
<p>因此，我们也可以看出：强弱符号和声明没任何关系。弱符号不会有static的storage duration。同名的多个弱符号的定义不应该出现在同一个翻译单元中，如果出现，链接器会选择第一个。</p>