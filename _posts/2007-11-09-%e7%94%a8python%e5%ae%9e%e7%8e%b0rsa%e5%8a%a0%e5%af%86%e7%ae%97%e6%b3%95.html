---
layout: post
title: 用Python实现RSA加密算法
date: 2007-11-09 17:33:33.000000000 -08:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Programming
tags: []
meta:
  _publicize_pending: '1'
  original_post_id: '253'
  _wp_old_slug: '253'
author:
  login: wangcong2015
  email: wangcong@rocketmail.com
  display_name: wangcong2015
  first_name: ''
  last_name: ''
permalink: "/2007/11/09/%e7%94%a8python%e5%ae%9e%e7%8e%b0rsa%e5%8a%a0%e5%af%86%e7%ae%97%e6%b3%95/"
---
<p><!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"><br />
<html><body>
<p>这学期开了一门网络安全课，应老师要求，最近要做RSA加密算法。前一篇文章中已经提到，我是用Python来实现的整个程序，而且速度上嘛，比用C实现的慢了很多。我还不清楚到底是寻找素数的算法存在问题，还是Python本身的问题。</p>
<p>关于RSA算法的讲解，最好的莫过于wikipedia上的<a href="http://en.wikipedia.org/wiki/RSA">RSA词条</a>。里面已经非常详细地说明了，这里就不再赘述。整个算法中要用到的数学算法有：<a href="http://en.wikipedia.org/wiki/Extended_Euclidean_algorithm">Extended Euclidean algorithm</a>，<a href="http://en.wikipedia.org/wiki/Miller-Rabin_primality_test">Miller-Rabin primality test</a>。当然，你还需要<a href="http://en.wikipedia.org/wiki/Modulo_operation">Modulo operation</a>的知识。</p>
<p>整个算法最关键的是找到合适的P，Q，以及求D。前者尤为关键，它几乎决定了整个程序的运行速度。所以，找到一个搜索大素数的好算法是核心问题。关于求D，我并没有使用Extended Euclidean algorithm，而是用了蛮力求解，没关系，这影响不大，关键还是刚才说的那个。</p>
<p>寻找素数的算法我使用了Miller-Rabin primality test，参考了gmp库源代码中nextprime的实现。但速度上仍然远不如C的实现。详细代码如下：</p>
<p>#!/usr/bin/env python</p>
<p>import random<br />
import string<br />
import math<br />
import sys</p>
<p>DEBUG = False</p>
<p>def nextprime(n):<br />
	i = n + 1 - n%2<br />
	while not probably_prime(i):<br />
		i+=2<br />
	return i<br />
	#i = n + 1 - n%2<br />
	#m = 2*n<br />
	#while i  0):<br />
		r.append(n % 2)<br />
		n = n / 2<br />
	return r</p>
<p>def test(a, n):<br />
	"""<br />
	Returns:<br />
	  - True, if n is complex.<br />
	  - False, if n is probably prime.<br />
	"""<br />
	b = toBinary(n - 1)<br />
	d = 1<br />
	for i in xrange(len(b) - 1, -1, -1):<br />
		x = d<br />
		d = (d * d) % n<br />
		if d == 1 and x != 1 and x != n - 1:<br />
			return True<br />
		if b[i] == 1:<br />
			d = (d * a) % n<br />
	if d != 1:<br />
		return True # Complex<br />
	return False # Prime</p>
<p>def MillerRabin(n, s = 15):<br />
	"""<br />
	  Returns:<br />
	    - True, if n is probably prime.<br />
	    - False, if n is complex.<br />
	"""<br />
	for j in xrange(1, s + 1):<br />
		a = random.randint(1, n - 1)<br />
		if (test(a, n)):<br />
			return False # n is complex<br />
	return True # n is prime</p>
<p>def probably_prime(n):<br />
	return MillerRabin(n)</p>
<p>def gcd(m, n):<br />
	while n:<br />
		m, n = n, m % n<br />
	return m</p>
<p>def genkey(bits=100):<br />
	BIG_NUM = []<br />
	P_INT = 0<br />
	Q_INT = 0<br />
	global P, Q, X, N, D, E</p>
<p>	for i in range(bits):<br />
		BIG_NUM.append(random.choice('0123456789'))</p>
<p>	P_INT = int(''.join(BIG_NUM))</p>
<p>	for i in range(bits):<br />
		BIG_NUM[i] = random.choice('0123456789')</p>
<p>	Q_INT = int(''.join(BIG_NUM))</p>
<p>	if DEBUG:<br />
		print "p=%d"%P_INT<br />
		print "q=%d"%Q_INT</p>
<p>	P = nextprime(P_INT)<br />
	Q = nextprime(Q_INT)</p>
<p>	if DEBUG:<br />
		print "next prime to p is %d"%P<br />
		print "next prime to q is %d"%Q</p>
<p>	N = P*Q<br />
	if DEBUG:<br />
		print "n=%d"%N</p>
<p>	X = (P-1)*(Q-1)<br />
	if DEBUG:<br />
		print "x=%d"%X</p>
<p>	while True:<br />
		if gcd(X, E)==1:<br />
			break<br />
		E+=2</p>
<p>	if DEBUG:<br />
		print "e=%d"%E</p>
<p>	n = 1<br />
	while (n*X+1)%E!=0:<br />
		n+=1<br />
	D = (n*X+1)/E</p>
<p>	if DEBUG:<br />
		print "d=%d"%D</p>
<p>def rsa_encrypt(msg):<br />
	enc = []<br />
	for c in msg:<br />
		enc.append(pow(ord(c), E, N))<br />
	return enc</p>
<p>def rsa_decrypt(cmsg):<br />
	dec = []<br />
	tmp = []<br />
	for ec in cmsg:<br />
		tmp.append(pow(ec, D, N))<br />
	for c in tmp:<br />
		dec.append("%c"%c)<br />
	return dec</p>
<p>X = N = D = P = Q = 0<br />
E= 65537</p>
<p>if __name__=="__main__":<br />
	DEBUG = True</p>
<p>	argc = len(sys.argv)<br />
	if argc==1:<br />
		genkey()<br />
	elif argc==2:<br />
		genkey(string.atoi(sys.argv[1]))<br />
	else:<br />
		sys.exit(-1)</p>
<p>	msg = raw_input()<br />
	enc = rsa_encrypt(msg)<br />
	if DEBUG:<br />
		print enc<br />
	dec = rsa_decrypt(enc)<br />
	print ''.join(dec)</p>
<p></body></html></p>
