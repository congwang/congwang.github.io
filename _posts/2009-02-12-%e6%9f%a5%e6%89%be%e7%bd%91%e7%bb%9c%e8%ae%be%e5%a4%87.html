---
categories:
- Programming
date: 2009-02-12 21:19:34-08:00
layout: post
permalink: /2009/02/12/%e6%9f%a5%e6%89%be%e7%bd%91%e7%bb%9c%e8%ae%be%e5%a4%87/
title: 查找网络设备
---
<p><br />

<p>在新闻组上看到有人问如何通过名字查找某个网络设备，其实不难，首先想到的就是通过ioctl，示例代码见下：</p>
<p>[c]<br />
int get_interface(const char *interface)<br />
{<br />
	int sock = socket(PF_INET, SOCK_STREAM, 0);<br />
	struct ifconf ifc;<br />
	struct ifreq *ifr;<br />
	int ret = -1;</p>
<p>	if (sock &lt; 0)<br />
		return -1;</p>
<p>	ifc.ifc_len = 0;<br />
	ifc.ifc_req = NULL;<br />
	if (ioctl(sock, SIOCGIFCONF, &amp;ifc)  0) {<br />
		ifc.ifc_req = malloc(ifc.ifc_len);<br />
		if (ifc.ifc_req) {<br />
			if (ioctl(sock, SIOCGIFCONF, &amp;ifc) &lt; 0) {<br />
				free(ifc.ifc_req);<br />
				goto close;<br />
			} else<br />
				for (ifr = ifc.ifc_req;<br />
				     (char *)ifr ifr_name);*/<br />
					if (!strcmp(ifr-&gt;ifr_name, interface)) {<br />
						ret = 0;<br />
						break;<br />
					}<br />
				}<br />
		} else<br />
			return -1;</p>
<p>		free(ifc.ifc_req);<br />
	}</p>
<p>close:<br />
	close(sock);<br />
	return ret;<br />
}<br />
[/c]</p>
<p>然后有人说POSIX其实还有个if_nameindex()，它明显要比ioctl可移植性要高，用它重写上面的代码如下：<br />
[c]<br />
int get_interf(const char *interf)<br />
{</p>
<p>	int ret = -1;<br />
	struct if_nameindex *ifp, *ifpsave;<br />
	ifpsave = ifp = if_nameindex();</p>
<p>	if (!ifp)<br />
		return -1;</p>
<p>	while (ifp-&gt;if_index) {<br />
		if (strcmp(ifp-&gt;if_name, interf) == 0) {<br />
			ret = 0;<br />
			break;<br />
		}<br />
		ifp++;<br />
	}</p>
<p>	if_freenameindex(ifpsave);<br />
	return ret;<br />
}<br />
[/c]</p>
<p>我查了一下glibc中的实现，发现在linux上其实如果不用netlink的话，if_nameindex()也就是对ioctl(...SIOCGIFCONF...)的一个包装，具体可参考sysdeps/unix/sysv/linux/if_index.c。netlink这个东西够奇怪的，在这里居然也能派上用场，有机会要研究研究～</p>
<p></p>