---
layout: post
title: __umoddi3()的问题
date: 2009-03-29 21:31:49.000000000 -07:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Linux Kernel
tags: []
meta:
  _publicize_pending: '1'
  original_post_id: '654'
  _wp_old_slug: '654'
author:
  login: wangcong2015
  email: wangcong@rocketmail.com
  display_name: wangcong2015
  first_name: ''
  last_name: ''
permalink: "/2009/03/29/__umoddi3%e7%9a%84%e9%97%ae%e9%a2%98/"
---
<p><!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"><br />
<html><body></p>
<p>在编译内核时有人遇到下面这个问题：</p>
<pre>
kernel/built-in.o: In function `getnstimeofday':
(.text+0xb6ae): undefined reference to `__umoddi3'
kernel/built-in.o: In function `getnstimeofday':
(.text+0xb6ce): undefined reference to `__udivdi3'
</pre>
<p>这个问题可以在用户空间重现，不过不是很容易，我实验了一下，在i386上，并不是所有的64位整数操作都会被转化成调用__umoddi3，<a target="_blank" href="http://gcc.gnu.org/bugzilla/show_bug.cgi?id=32044">gcc bugzilla上</a>有演示程序，如下：</p>
<p>[c]<br />
#define NSEC_PER_SEC  1000000000UL<br />
int rmg(void);</p>
<p>int main(void)<br />
{<br />
        /* int sec; */<br />
        return rmg();<br />
}</p>
<p>int rmg(void)<br />
{<br />
static unsigned long long nsec = 0;<br />
static int sec = 0;<br />
    while (sec = NSEC_PER_SEC, 0)) {<br />
                nsec -= NSEC_PER_SEC;<br />
                ++sec;<br />
        }<br />
    }<br />
        return sec;<br />
}<br />
[/c]</p>
<p>这样编译它：% gcc -nostdlib -O2 -o umoddi3 umoddi3.c，就会得到：</p>
<pre>
/tmp/ccycM684.o: In function `rmg':
umoddi3.c:(.text+0x87): undefined reference to `__udivdi3'
collect2: ld returned 1 exit status
</pre>
<p>问题重现了。这里的问题是，对于nsec来说，内层的循环其实等价于求模运算，gcc在优化时发现了这一点，而且硬件本身也不支持对64位整数直接进行算术运算，所以gcc会把这一步优化成调用内部函数__udivdi3()和__umoddi3()，这两个函数在libgcc中（见gcc源代码gcc/libgcc2.c），libgcc默认和libc一样是要被加载的，但如果我们加了-nostdlib（Linux内核是更好的例子），这个问题就会出现了。</p>
<p>知道原因了，怎么解决？网上有两种方法，一种是像<a target="_blank" href="http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commitdiff;h=38332cb98772f5ea757e6486bed7ed0381cb5f98;hp=e48af19f56eb47a1f908ee8f16df9d246f955b21">这个补丁</a>那样，在循环中插入下面这条内联汇编：</p>
<pre>
asm("" : "+r"(ns));
</pre>
<p>这句是告诉gcc把ns这个变量放到寄存器中，并且既有读操作也有写操作，所以后面再用它时必须重新读取，这样就消除了上面的优化。</p>
<p>另一种解决方法是添加新的编译选项：-fno-tree-scev-cprop，这个选项似乎没有文档，至少我没找到。说说它的大体意思。scev应该是SCalar EVolutions，什么意思不知道。:( cprop应该是Copy PROPagation，这个应该很容易理解，就是赋值的传播，比如：</p>
<p>i = 10;<br />
a = i;<br />
b = i;</p>
<p>其实就是：</p>
<p>a = 10;<br />
b = 10;</p>
<p>可见，编译优化是门大学问，写个编译器丝毫不比写个内核容易。:-P</body></html></p>
