---
layout: post
title: 一个正确使用gets的方法
date: 2007-11-10 21:14:01.000000000 -08:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Programming
tags: []
meta:
  _publicize_pending: '1'
  original_post_id: '254'
  _wp_old_slug: '254'
author:
  login: wangcong2015
  email: wangcong@rocketmail.com
  display_name: wangcong2015
  first_name: ''
  last_name: ''
permalink: "/2007/11/10/%e6%ad%a3%e7%a1%ae%e4%bd%bf%e7%94%a8gets%e7%9a%84%e6%96%b9%e6%b3%95/"
---
<p><!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"><br />
<html><body>
<p>gets太臭名昭著了，因为它是缓冲区溢出的最大祸根之一。连Linux Programmer’s Manual里都说：“Never use gets().”。没错，你几乎就没有能正确使用它的方法，因为它根本就不关心缓冲区到底够不够，只是一股脑地往里写数据。 如果你写了带gets的程序，gcc甚至会提示：“ warning: the `gets' function is dangerous and should not be used.”。</p>
<p>可是，如果我们仔细想想，究竟有没有正确使用gets的时候？答案是肯定的。那怎么才能正确使用gets呢？其实也很简单，我们只要设置保卫页面（guard pages）来对付溢出就可以了。在Linux上，我们可以这么做：</p>
<p>#include<br />
#include<br />
#include </p>
<p>int main(void){<br />
	int pagesize;<br />
	void *p;<br />
	char *buf;<br />
	size_t buflen = 4;</p>
<p>	pagesize = getpagesize();<br />
	p = mmap(NULL, 2*pagesize, PROT_READ, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);<br />
	if (p == MAP_FAILED) {<br />
		perror("mmap");<br />
		return -1;<br />
	}<br />
	if (mprotect(p, pagesize, PROT_READ|PROT_WRITE)){<br />
		perror("mprotect");<br />
		munmap(p, 2*pagesize);<br />
		return -1;<br />
	}<br />
	buf = (char*)p + pagesize - buflen;<br />
#ifdef DEBUG<br />
	printf("buf=%p, p=%pn", buf, p);<br />
#endif<br />
	gets(buf);<br />
	puts(buf);<br />
	munmap(p, 2*pagesize);<br />
	return 0;<br />
}</p>
<p>这时，如果写入的数据超出我们的缓冲区，程序就会收到SIGSEGV而退出。</p>
<p></body></html></p>
