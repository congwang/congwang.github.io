---
layout: post
title: 自动生成内核config
date: 2010-04-21 23:16:16.000000000 -07:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Linux Kernel
tags: []
meta:
  _publicize_pending: '1'
  original_post_id: '1084'
  _wp_old_slug: '1084'
author:
  login: wangcong2015
  email: wangcong@rocketmail.com
  display_name: wangcong2015
  first_name: ''
  last_name: ''
permalink: "/2010/04/21/%e8%87%aa%e5%8a%a8%e7%94%9f%e6%88%90%e5%86%85%e6%a0%b8config/"
---
<p><!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"><br />
<html><body>
<p>配置内核的人都清楚要选择内核的配置项是一件比较麻烦的事：要是多选了吧，内核体积可能变大，编译时间会变长；要是选少了吧，恐怕系统连启动都启动不了。所以一般我们的做法是拿过系统提供的 config 来直接make oldconfig。</p>
<p>但这么做并不是很好，因为发行版通常为了照顾不同配置的机器而选中了很多的模块，这样一来对本机器没有用的东西也会被编译进来，从而导致编译时间变长，这还是次要，关键是模块数量会增多，内核体积也有可能变大。</p>
<p>理想的情况是我们根据本系统运行时加载的模块来决定到底选中哪些模块。问题就来了，我们怎么才能知道自己的系统需要哪些模块不需要哪些模块呢？</p>
<p>为了解决这个问题，Steven Rostedt写了一个脚本，叫作<a href="http://rostedt.homelinux.com/code/streamline_config.pl" target="_blank">streamline_config.pl</a>，来解决这个问题。而且他已经把此脚本提交到内核，见scripts/kconfig/streamline_config.pl。这样一来，我们就可以通过 make localmodconfig 或 make localyesconfig 来生成我们真正需要的最小的config了。不同的是，后者会把系统正在使用模块编译进内核，而前者不会，它只会保留系统使用的模块而且继续以模块的形式存在。</p>
<p>这个脚本不复杂，原理也很简单，通过 lsmod 找出正在使用的驱动， 然后通过解析所有的Makefile中的obj-$(CONFIG_XXX) += xxx.o模式来找到驱动对应的CONFIG_*，不过还要解决依赖性的问题。</p>
<p></body></html></p>
